/*
This script performs a full exploratory data analysis (EDA) and business analysis
on an e-commerce dataset. It includes:

- Initial data exploration: inspecting tables, adding columns, and basic aggregations.
- Business problem analyses: identifying top-selling products, revenue by category,
  average order value (AOV), monthly sales trends, customers without purchases,
  least-selling categories by state, customer lifetime value (CLTV), inventory alerts,
  shipping delays, payment rates, top sellers, product profit margins, and return rates.
- Customer behavior insights: categorizing customers as new or returning, and
  identifying top customers by state.
- Revenue trend analysis: detecting products with the highest revenue decrease year-over-year.
- Final task: creating a stored procedure that updates inventory automatically
  when a new order is placed, ensuring stock levels remain accurate after each sale.

The script includes CTEs, ranking functions, window functions, aggregations,
and error-handling mechanisms for robust analysis and data operations.
*/


/*
=========================================================================
EDA
=========================================================================
*/

SELECT * FROM Customers;
SELECT * FROM Category;
SELECT * FROM Inventory;
SELECT * FROM Order_items;
SELECT * FROM Orders;
SELECT * FROM Payments;
SELECT * FROM Products;
SELECT * FROM Sellers;
SELECT * FROM Shipping;

ALTER TABLE customers
ADD full_name VARCHAR(50)

UPDATE customers
SET full_name = CONCAT(first_name,' ',last_name)

--Customers countries
SELECT DISTINCT state 
FROM Customers

--Count order by status
SELECT order_status, count(*) as total_per_status
FROM Orders
GROUP BY order_status

--Last order date
SELECT MAX(order_date) as most_recent_order
FROM Orders

--Count payments by status
SELECT payment_status,count(*) as total_per_status
FROM Payments
GROUP BY payment_status
ORDER BY 2 DESC

--Number of products
SELECT DISTINCT count(product_name) as unique_products
FROM Products

--Number of products per category
SELECT c.category_id,c.category_name,count(*) AS num_of_products
FROM Products p join Category c on p.category_id = c.category_id
GROUP BY c.category_id,c.category_name
ORDER BY 3 DESC


--Shippings per status
SELECT delivery_status, count(*) as total_per_status
FROM Shipping
GROUP BY delivery_status
ORDER BY 2 DESC

--returned products
SELECT COUNT(*) AS returned_products
FROM Shipping
WHERE return_date IS NOT NULL

--shipments per provider
SELECT shipping_providers,count(*) AS total_shipment_per_providers
FROM Shipping
GROUP BY shipping_providers
ORDER BY 2 DESC

--===============================================================
--Business problems analysis
--===============================================================

/*
1. Top Selling Products
Query the top 10 products by total sales value.
*/

--ADDING  AND UPDATING COLUMN
ALTER TABLE order_items 
ADD  total_value DECIMAL(10,2);

UPDATE Order_items
SET total_value = quantity*price_per_unit;

--Query
SELECT TOP 10 p.product_name,SUM(quantity) AS total_quantity_sold,
       ROUND(SUM(oi.total_value),2) AS total_sales_value
FROM Products p join Order_items oi on p.product_id = oi.product_id
GROUP BY p.product_name
ORDER BY 3 DESC;

/*
2. Revenue by Category
Calculating total revenue generated by each product category.
*/


SELECT c.category_id, c.category_name,SUM(oi.total_value) AS total_contribution,
       (FORMAT((SUM(oi.total_value)/(SELECT sum(total_value) 
                            FROM Order_items) )* 100,'0.#') + '%') AS Precentage_contribution
FROM Products p LEFT JOIN Category c ON p.category_id = c.category_id
LEFT JOIN Order_items oi ON p.product_id = oi.product_id
GROUP BY c.category_id, c.category_name
ORDER BY 3 DESC



/*
3. Average Order Value (AOV)
average order value for each customer.
*/

SELECT c.customer_id,
       CONCAT(c.first_name,' ',c.last_name) AS full_name,
       SUM(oi.total_value)/COUNT(oi.order_id) AS AOV,
	   COUNT(oi.order_id) AS total_orders
FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id JOIN
Order_items oi ON o.order_id = oi.order_id
GROUP BY c.customer_id,c.first_name, c.last_name
HAVING count(oi.order_id) >= 5
ORDER BY 3 DESC


/*
4. Monthly Sales Trend
monthly total Value over the past year.
*/

SELECT MONTH(o.order_date) AS month,
       SUM(oi.total_value) AS Monthly_value,
	   LAG(SUM(oi.total_value)) OVER(ORDER BY MONTH(order_date)) AS Last_month_sales,
	   CASE WHEN SUM(oi.total_value) > LAG(SUM(oi.total_value)) OVER(ORDER BY MONTH(order_date))
	        THEN 'Increase'
			WHEN SUM(oi.total_value) < LAG(SUM(oi.total_value)) OVER(ORDER BY MONTH(order_date))
			THEN 'Decrease'
			WHEN MONTH(o.order_date) = 1 THEN 'First Month'
			ELSE 'Even' END AS changes
FROM Orders o JOIN Order_items oi ON o.order_id = oi.order_id
WHERE YEAR(order_date) = 2024
GROUP BY MONTH(order_date)
ORDER BY 1 
/*
5. Customers with No Purchases
customers who have registered but never placed an order.
Challenge: List customer details and the time since their registration.
*/
SELECT customer_id,full_name,state
FROM Customers 
WHERE customer_id IN (
(SELECT customer_id
FROM Customers)
EXCEPT
(SELECT c.customer_id
FROM Orders o JOIN Customers c ON o.customer_id = c.customer_id))


--Checking
WITH registered_without_order AS (
    SELECT COUNT(*) AS count_registered_without_order
    FROM (
        (SELECT customer_id FROM Customers)
        EXCEPT
        (SELECT customer_id FROM Orders)
    ) AS t
),
total_customers AS (
    SELECT COUNT(*) AS total_customers
    FROM Customers
),
customers_with_orders AS (
    SELECT COUNT(DISTINCT o.customer_id) AS count_customers_with_orders
    FROM Orders o
)
SELECT 
    rwo.count_registered_without_order+cwo.count_customers_with_orders AS total_WithOrWithout_Orders,
    tc.total_customers
   
FROM 
    registered_without_order rwo,
    total_customers tc,
    customers_with_orders cwo;


/*
6. Least-Selling Categories by State
least-selling product category for each state.
*/
SELECT t.state,t.category_name,t.total_sales,t.total_orders
FROM (
SELECT cu.state,c.category_name,COUNT(o.order_id) AS total_orders,
       RANK() OVER(PARTITION BY cu.state ORDER BY COUNT(o.order_id)) AS order_ranking,
	   SUM(oi.total_value) AS total_sales
FROM Orders o JOIN Order_items oi ON o.order_id = oi.order_id
     JOIN Products p ON p.product_id = oi.product_id
	 JOIN Category c ON c.category_id = p.category_id
	 JOIN Customers cu on o.customer_id = cu.customer_id
GROUP BY cu.state,c.category_name) t
WHERE order_ranking = 1

/*
7. Customer Lifetime Value (CLTV)
total value of orders placed by each customer over their lifetime.

*/

SELECT cu.customer_id,cu.full_name,
       SUM(oi.total_value) AS CLTV,
	   DENSE_RANK() OVER(ORDER BY SUM(oi.total_value) DESC) AS CLTV_ranking
FROM Orders o JOIN Order_items oi ON o.order_id = oi.order_id
	 JOIN Customers cu on o.customer_id = cu.customer_id
GROUP BY cu.customer_id,cu.full_name

/*
8. Inventory Stock Alerts
 products with stock levels below a certain threshold (e.g., less than 10 units).
*/

SELECT *
FROM Inventory i JOIN Products p ON i.product_id = p.product_id
WHERE i.stock_remaining < 10
ORDER BY i.stock_remaining


/*
9. Shipping Delays
Providers where the shipping date is later than 3 days after the order date.
*/
SELECT shipping_providers,
       COUNT(*) AS delayed_orders
FROM(
SELECT c.customer_id,c.full_name,
       o.order_id,o.order_date,o.order_status,
	   s.shipping_id,s.shipping_date,s.shipping_providers,s.delivery_status
FROM Shipping s JOIN Orders o ON s.order_id = o.order_id
     JOIN Customers c on c.customer_id = o.customer_id
WHERE DATEDIFF(DAY,o.order_date,s.shipping_date) > 3) t
GROUP BY shipping_providers
ORDER BY 2 DESC;

/*
10. Payment  Rate 
Calculate the percentage of payments status across all orders.
*/

SELECT
   CONCAT(ROUND(CAST((SUM(CASE WHEN payment_status = 'Payment Successed' THEN 1 ELSE 0 END) * 100.0) / 
   COUNT(*) AS FLOAT),2),'%') AS payment_success_percentage,
   CONCAT(ROUND(CAST((SUM(CASE WHEN payment_status = 'Refunded ' THEN 1 ELSE 0 END) * 100.0) / 
   COUNT(*) AS FLOAT),2),'%') AS payment_refunded_percentage,
      CONCAT(ROUND(CAST((SUM(CASE WHEN payment_status = 'Payment Failed ' THEN 1 ELSE 0 END) * 100.0) / 
   COUNT(*) AS FLOAT),2),'%') AS payment_failed_percentage
FROM Payments;


/*
11. Top Performing Sellers
top 5 sellers based on total sales value.
*/

SELECT TOP 5 s.seller_id,s.seller_name,s.origin,
       Count(*) AS total_sales,
	   SUM(oi.total_value) AS total_value,
       CONCAT(ROUND(CAST(SUM(CASE WHEN o.order_status = 'Completed' THEN 1 ELSE 0 END) * 100.0 
      / COUNT(*) AS FLOAT), 2),'%') AS completed_percentage
FROM Sellers s JOIN Orders o ON s.seller_id = o.seller_id 
     JOIN Order_items oi ON oi.order_id = o.order_id
GROUP BY s.seller_id,s.seller_name,s.origin
ORDER BY 5 DESC

/*
12. Product Profit Margin
profit margin for each product (difference between price and cost of goods sold).
*/

SELECT p.product_id,p.product_name,
       ROUND(SUM(oi.total_value - oi.quantity*p.cogs),2) AS profit_margin,
	   DENSE_RANK() OVER (ORDER BY SUM(p.price-p.cogs) DESC) AS Ranking_by_margin
FROM Products p JOIN Order_items oi ON p.product_id = oi.product_id
GROUP BY p.product_id,p.product_name


/*
13. Most Returned Products
top 10 products by the number of returns.
*/

SELECT TOP 10 p.product_name,
       SUM(CASE WHEN s.delivery_status = 'Returned' THEN 1
	        ELSE 0 END) AS total_returned,
	   CONCAT(ROUND(CAST(SUM(CASE WHEN s.delivery_status = 'Returned' THEN 1 ELSE 0 END) * 100.0 
      / COUNT(*) AS FLOAT), 2),'%') AS return_rate
FROM Shipping s LEFT JOIN Order_items oi ON oi.order_id = s.order_id
     JOIN Products p on p.product_id = oi.product_id
GROUP BY p.product_name
ORDER BY 2 DESC 


/*
Customer Purchase Frequency and Value Summary
*/
WITH customer_order_diff AS(
SELECT c.customer_id,c.full_name,c.state,o.order_date,oi.total_value,
       DATEDIFF(DAY,LAG(o.order_date) 
	                OVER(PARTITION BY c.customer_id ORDER BY order_date),o.order_date) 
					AS Order_date_diff
FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id JOIN Order_items oi
     ON oi.order_id = o.order_id
)

SELECT customer_id,full_name,state,
       SUM(total_value) as total_value,
       AVG(order_date_diff) AS avg_date_diff
FROM customer_order_diff
WHERE Order_date_diff IS NOT NULL
GROUP BY customer_id,full_name,state,total_value
ORDER BY 5 DESC


/*
16. IDENTITY customers into returning or new
if the customer has done more than 5 return categorizing them as returning otherwise new
*/
WITH customer_returns AS (
SELECT c.customer_id,c.full_name,
       COUNT(*) AS total_orders,
	   SUM(CASE WHEN o.order_status = 'Returned' THEN 1
	        ELSE 0 END) AS total_returned
FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id JOIN Order_items oi
     ON oi.order_id = o.order_id
GROUP BY c.customer_id,c.full_name
)

SELECT*,
      CASE WHEN total_returned > 5 THEN 'returning'
	       ELSE 'new' END AS customer_type
FROM customer_returns
ORDER BY total_returned DESC

/*
17. Top 5 Customers by Orders in Each State
top 5 customers with the highest order value for each state.
*/
WITH customer_values AS (
SELECT c.customer_id,c.full_name,c.state,
       SUM(oi.total_value) AS total_value,
	   COUNT(*) AS total_orders,
	   RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.total_value) DESC) AS value_ranking
FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id JOIN Order_items oi
     ON oi.order_id = o.order_id
GROUP BY c.customer_id,c.full_name,c.state
)

SELECT state,customer_id,full_name,total_value,total_orders
FROM customer_values
WHERE value_ranking between 1 AND 5
ORDER BY state,value_ranking 


/*
19. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)

 Decrease ratio = cr-ls/ls* 100 (cs = current_year ls=last_year)
*/

WITH year_revenue AS (
SELECT YEAR(order_date) AS year,p.product_name,c.category_name,
       SUM(oi.total_value) AS total_value,
	   LAG(sum(oi.total_value)) OVER(PARTITION BY p.product_name,c.category_name order by YEAR(order_date)) AS last_year_value      
FROM Order_items oi JOIN Products P ON oi.product_id = p.product_id
     JOIN Orders o ON oi.order_id = o.order_id JOIN Category c ON c.category_id = p.category_id
WHERE YEAR(o.order_date) IN (2022,2023)
GROUP BY YEAR(order_date),p.product_name,c.category_name)

SELECT TOP 10 product_name,category_name,
      ROUND( total_value-last_year_value/total_value,2) AS decrease_ratio
FROM year_revenue
WHERE  total_value-last_year_value/total_value IS NOT NULL
ORDER BY 3 DESC


/*
Final Task
-- Store Procedure
create a function as soon as the product is sold the the same quantity should reduced from inventory table
after adding any sales records it should update the stock in the inventory table based on the product and qty purchased
-- 
*/


CREATE OR ALTER PROCEDURE quantity_update 
    @product_id INT,
    @quantity INT,
    @total_value INT
AS
BEGIN
    BEGIN TRY
        BEGIN TRANSACTION;

        -- בדיקה אם יש מספיק מלאי
        IF EXISTS (
            SELECT 1
            FROM Inventory
            WHERE product_id = @product_id AND stock_remaining >= @quantity
        )
        BEGIN
		    DECLARE @price_per_unit INT;
            SELECT @price_per_unit = MAX(price_per_unit)
            FROM Order_items
            WHERE product_id = @product_id;

			DECLARE @order_item_id INT;
			SELECT @order_item_id = MAX(order_items_id)+1
			FROM Order_items

			DECLARE @order_id INT;
			SELECT @order_id = MAX(order_id) + 1
			FROM Order_items


            SET @price_per_unit = ISNULL(@price_per_unit, 0);

            INSERT INTO Order_items (order_items_id, order_id, product_id, quantity, price_per_unit, total_value)
            VALUES (@order_item_id, @order_id, @product_id, @quantity, @price_per_unit, @total_value);

            UPDATE Inventory
            SET stock_remaining = stock_remaining - @quantity
            WHERE product_id = @product_id;
        END
        ELSE
        BEGIN
            THROW 50001, 'Insufficient inventory for this product.', 1;
        END

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
        RAISERROR(@ErrorMessage, 16, 1);
    END CATCH
END;

SELECT * FROM Inventory WHERE product_id = 1;
SELECT * FROM Order_items WHERE product_id = 1;



